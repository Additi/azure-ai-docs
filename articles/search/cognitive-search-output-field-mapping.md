---
title: Map skill output fields
titleSuffix: Azure Cognitive Search
description: Export the enriched content created by a skillset by mapping its output fields to fields in a search index.

author: HeidiSteen
ms.author: heidist
ms.service: cognitive-search
ms.topic: conceptual
ms.date: 09/14/2022
---

# Map enriched output to fields in a search index in Azure Cognitive Search

![Indexer Stages](./media/cognitive-search-output-field-mapping/indexer-stages-output-field-mapping.png "indexer stages")

This article explains how to set up *output field mappings* that determine a data path between in-memory data structures created during skill processing, and target fields in a search index. An output field mapping is defined in an [indexer](search-indexer-overview.md) and has the following elements:

```json
"outputFieldMappings": [
  {
    "sourceFieldName": "document/path-to-a-node-in-an-enriched-document",
    "targetFieldName": "some-search-field-in-an-index",
    "mappingFunction": null
  }
],
```

In contrast with a ["fieldMappings" definition](search-indexer-field-mappings.md) that maps a path between two physical data structures, an "outputFieldMappings" definition maps in-memory data to fields in a search index.

Output field mappings are required if your indexer has an attached [skillset](cognitive-search-working-with-skillsets.md) that creates new information, such as translated strings or key phrases. During indexer execution, AI-generated information exists in memory. To persist this information in a search index, you'll need to tell the indexer where to send the data.

Output field mappings can also be used to flatten nested data structures during indexing. A regular [fieldMapping definition](search-indexer-field-mappings.md) doesn't support target fields of a complex type. If you need to set up field associations for hierarchical or nested data structures, you can use a skillset and an output field mapping to create the data path.

Output field mappings apply to:

+ Content that's created by skills or extracted by an indexer.

+ Search indexes. If you're populating a [knowledge store](knowledge-store-concept-intro.md), use [projections](knowledge-store-projections-examples.md) for data path configuration.

Output field mappings always occur after [skillset execution](cognitive-search-working-with-skillsets.md), although it is possible for this stage to run even if no skillset is defined.

<!-- 
The enriched document is really a tree of information, and even though there is support for complex types in the index, sometimes you may want to transform the information from the enriched tree into a more simple type (for instance, an array of strings). 

Examples of output field mapping scenarios:

* **Content consolidation.** Your skillset extracts the names of organizations mentioned in within each page of a document. Now you want to map each of those organization names into a field in your index of type Edm.Collection(Edm.String).

* **Content creation.** As part of your skillset, you produced a new node called "document/translated_text". You would like to map this new information to a specific field in your index.

* **Content extraction.** You don’t have a skillset but are indexing a complex type from a Cosmos DB database. You'd like to get to a node on that complex type and map it into a field in your index. -->

## Set up an `outputFieldMappings` array

Output field mappings are added to the "outputFieldMappings" array in an indexer definition, typically placed after the "filedMappings" array. An output field mapping consists of three parts.

```json
"fieldMappings": []
"outputFieldMappings": [
  {
    "sourceFieldName": "document/path-to-a-node-in-an-enriched-document",
    "targetFieldName": "some-search-field-in-an-index",
    "mappingFunction": null
  }
],
```

| Property | Description |
|----------|-------------|
| "sourceFieldName" | Required. Specifies a path to enriched content |
|  "targetFieldName" | Optional. Specifies the search field that receives the enriched content|
| "mappingFunction" | Optional. Adds extra processing provided by [search-indexer-field-mappings.md#predefined functions](#mappingFunctions) supported by indexers. In the case of enrichment nodes, encoding and decoding are the most commonly used functions. |

You can use the REST API or an Azure SDK to define output field mappings.

> [!TIP]
> Indexers created by the [Import data wizard](search-import-data-portal.md) include output field mappings generated by the wizard. If you need examples, run the wizard over your data source to see the full definition.

### [**REST APIs**](#tab/rest)

Use [Create Indexer (REST)](/rest/api/searchservice/create-Indexer) or [Update Indexer (REST)](/rest/api/searchservice/update-indexer), any API version.

This example adds entities and sentiment labels extracted from a blob's content property to fields in a search index.

```JSON
PUT https://[service name].search.windows.net/indexers/myindexer?api-version=[api-version]
Content-Type: application/json
api-key: [admin key]
{
    "name": "myIndexer",
    "dataSourceName": "myDataSource",
    "targetIndexName": "myIndex",
    "skillsetName": "myFirstSkillSet",
    "fieldMappings": [],
    "outputFieldMappings": [
        {
            "sourceFieldName": "/document/content/organizations/*/description",
            "targetFieldName": "descriptions",
            "mappingFunction": {
                "name": "base64Decode"
            }
        },
        {
            "sourceFieldName": "/document/content/organizations",
            "targetFieldName": "orgNames"
        },
        {
            "sourceFieldName": "/document/content/sentiment",
            "targetFieldName": "sentiment"
        }
    ]
}
```

For each output field mapping, set the location of the data in the enriched document tree (sourceFieldName), and the name of the field as referenced in the index (targetFieldName). Assign any [mapping functions](search-indexer-field-mappings.md#field-mapping-functions-and-examples) that you require to transform the content of a field before it's stored in the index.

### [**.NET SDK (C#)**](#tab/csharp)

In the Azure SDK for .NET, use the [OutputFieldMappingEntry](/dotnet/api/azure.search.documents.indexes.models.outputfieldmappingentry) class that provides "Name" and "TargetFieldName" properties and an optional "MappingFunction" reference.

Specify output field mappings when constructing the indexer, or later by directly setting [SearchIndexer.OutputFieldMappings](/dotnet/api/azure.search.documents.indexes.models.searchindexer.outputfieldmappings). The following C# example sets the output field mappings when constructing an indexer.

```csharp
string indexerName = "cog-search-demo";
SearchIndexer indexer = new SearchIndexer(
    indexerName,
    dataSourceConnectionName,
    indexName)
{
    // Field mappings omitted for this example (assume default mappings)
    OutputFieldMappings =
    {
        new FieldMapping("/document/content/organizations") { TargetFieldName = "orgNames" },
        new FieldMapping("/document/content/sentiment") { TargetFieldName = "sentiment" }
    },
    SkillsetName = skillsetName
};

await indexerClient.CreateIndexerAsync(indexer);
```
 -->

---

<a name="flatten-information-from-complex-types"></a>

## Flatten complex structures for data import

The path in a sourceFieldName can represent one element or multiple elements. In the example above, ```/document/content/sentiment``` represents a single numeric value, while ```/document/content/organizations/*/description``` represents several organization descriptions. 

In cases where there are several elements, they are "flattened" into an array that contains each of the elements. 

More concretely, for the ```/document/content/organizations/*/description``` example, the data in the *descriptions* field would look like a flat array of descriptions before it gets indexed:

```
 ["Microsoft is a company in Seattle","LinkedIn's office is in San Francisco"]
```

This is an important principle, so we will provide another example. Imagine that you have an array of complex types as part of the enrichment tree. Let's say there is a member called customEntities that has an array of complex types like the one described below.

```json
{
   "document/customEntities":[
      {
         "name":"heart failure",
         "matches":[
            {
               "text":"heart failure",
               "offset":10,
               "length":12,
               "matchDistance":0.0
            }
         ]
      },
      {
         "name":"morquio",
         "matches":[
            {
               "text":"morquio",
               "offset":25,
               "length":7,
               "matchDistance":0.0
            }
         ]
      }
   ]
}
```

Let's assume that your index has a field called 'diseases' of type Collection(Edm.String), where you would like to store each of the names of the entities. 

This can be done easily by using the "\*" symbol, as follows:

```json
    "outputFieldMappings": [
        {
            "sourceFieldName": "/document/customEntities/*/name",
            "targetFieldName": "diseases"
        }
    ]
```

This operation will simply “flatten” each of the names of the customEntities elements into a single array of strings like this:

```json
  "diseases" : ["heart failure","morquio"]
```

## See also

+ [Define field mappings in a search indexer](search-indexer-field-mappings.md)
+ [AI enrichment overview](cognitive-search-concept-intro.md)
+ [Skillset overview](cognitive-search-working-with-skillsets.md)